temp_fit<-splinefun(test_doses,me)
#BMD Estimates fit - MLE/Laplace why they don't have it yet..?
out2<-out+geom_smooth(aes(x=test_doses,y=me),col="blue")+geom_point(aes(x=doses,y=probs))
out3<-out2+geom_segment(aes(x=fit$bmd, y=temp_fit(x=fit$bmd), xend=fit$bmd, yend=0), color="Red")
return(out3)
# BMD Sample
#
#     if (BMD_DENSITY ==TRUE){
#       Dens =  density(temp,cut=c(max(doses)))
#       # what is this 0.4 means? Scale?
#       Dens$y = Dens$y/max(Dens$y) * max(probs)*0.4
#       temp = which(Dens$x < max(doses))
#       D1_y = Dens$y[temp]
#       D1_x = Dens$x[temp]
#
#       #geom ploygon
#       # geom_polygon(aes(x=c(test_doses,test_doses[length(test_doses):1]),y=c(uq,lq[length(test_doses):1])), fill="blue",alpha=0.1)
#       #polygon(c(0,D1_x,max(doses)),c(0,D1_y,0),col = alphablend(col=density_col,0.2),border =alphablend(col=density_col,0.2))
#
#       out4<-out3+geom_polygon(aes(x=c(0,D1_x,max(doses)),y=c(0,D1_y,0)), fill = "lightblue", alpha=0.7)
#
#       return(out4)
#     }
}
.plot.BMDdich_fit_maximized(A_single_laplace)
.plot.BMDdich_fit_maximized(A_single_laplace)
# Single model fitting
A_single_mcmc<-single_dichotomous_fit(mData[,1],mData[,2],mData[,3], model_type="hill",fit_type="mcmc")
plot(A_single_mcmc)
.plot.BMDdich_fit_MCMC(A_single_mcmc)
plot(A_single_mcmc)
.plot.BMDdich_fit_MCMC(A_single_mcmc)
.plot.BMDdich_fit_MCMC(A_single_mcmc)
.plot.BMDdich_fit_MCMC <-function(fit,fit_type="MCMC",qprob=0.05,...){
density_col="red"
credint_col="azure2"
BMD_DENSITY = T
if (qprob < 0 || qprob > 0.5){
stop( "Quantile probability must be between 0 and 0.5")
}
# How this is calculated?
# This part - how it is derived?
probs <- (0.5+fit$data[,2,drop=T])/(1.0 + fit$data[,3,drop=T])
se <- sqrt(probs*(1-probs)/fit$data[,3,drop=T])
doses = fit$data[,1,drop=T]
uerror <- apply(cbind(probs*0+1,probs+se),1,min)
lerror <- apply(cbind(probs*0,probs-se),1,max)
dose = c(doses,doses)
Response = c(uerror,lerror)
# Basic structure of display
# main should show the models' information, I think this part should be fixed.
# Dichotomous's response is between 0 to 1
# Change this to ggplot object
#plot(dose,Response,type='n',main=fit$fitted_model$full_model)
# We need to adjust the range here too
# S3 object not fitted here for the title part
out<-ggplot()+
geom_errorbar(aes(x=doses, ymin=lerror, ymax=uerror),color="grey")+xlim(c(min(dose)-0.5,max(dose)+0.5))+ylim(c(0,1))+labs(x="Dose", y="Proportion",title=paste(fit$fitted_model$full_model, fit_type,sep=",  Fit Type: " ))+theme_minimal()
test_doses <- seq(min(doses),max(doses)*1.03,(max(doses)*1.03-min(doses))/100)
if (fit$model=="hill"){
Q <- apply(fit$mcmc_result$PARM_samples,1,.dich_hill_f, d=test_doses)
}
if (fit$model=="gamma"){
Q <- apply(fit$mcmc_result$PARM_samples,1,.dich_gamma_f, d=test_doses)
}
if (fit$model=="logistic"){
Q <- apply(fit$mcmc_result$PARM_samples,1,.dich_logist_f, d=test_doses)
}
if (fit$model=="log-logistic"){
Q <- apply(fit$mcmc_result$PARM_samples,1,.dich_llogist_f, d=test_doses)
}
if (fit$model=="probit"){
Q <- apply(fit$mcmc_result$PARM_samples,1,.dich_probit_f, d=test_doses)
}
if (fit$model=="log-probit"){
Q <- apply(fit$mcmc_result$PARM_samples,1,.dich_lprobit_f, d=test_doses)
}
if (fit$model=="multistage"){
Q <- apply(fit$mcmc_result$PARM_samples,1,.dich_multistage_f, d=test_doses)
}
if (fit$model=="qlinear"){
Q <- apply(fit$mcmc_result$PARM_samples,1,.dich_qlinear_f, d=test_doses)
}
if (fit$model=="weibull"){
Q <- apply(fit$mcmc_result$PARM_samples,1,.dich_weibull_f, d=test_doses)
}
temp <- fit$mcmc_result$BMD_samples[!is.nan(fit$mcmc_result$BMD_samples)]
temp <- temp[!is.infinite(temp)]
test <- density(temp)
Q <- t(Q)
me <- colMeans(Q)
lq <- apply(Q,2,quantile, probs = qprob)
uq <- apply(Q,2,quantile, probs = 1-qprob)
# Splien function is used to test column everage from MCMC
temp_fit <- splinefun(test_doses,me)
# Object 2
# Option- color , border- credint_col
# Ploygon object alpha need to be decided- should be transparent
# Input - color , check
#polygon(c(test_doses,test_doses[length(test_doses):1]),
#        c(uq,lq[length(test_doses):1]),col = credint_col, border=credint_col)
# Polygon changed to Geom_ribbon
out2<-out+geom_ribbon(aes(x=test_doses,ymin=lq,ymax=uq),fill="blue",alpha=0.1)
out2<-out+geom_polygon(aes(x=c(test_doses[length(test_doses):1],test_doses),y=c(uq[length(test_doses):1],lq)),fill="blue",alpha=0.1)
out3<-out2+geom_smooth(aes(x=test_doses,y=me),col="blue")+geom_point(aes(x=doses,y=probs))
# This part is for referecne
#geom_segment(data=bmd_dots, aes(x=H.bmd, y=.dich_weibull_f.H.fitted_model.parameters..H.bmd., xend=H.bmd, yend=0), color="Red")+
out4<-out3+geom_segment(aes(x=fit$bmd, y=temp_fit(x=fit$bmd), xend=fit$bmd, yend=0), color="Red")
out4
#
# if(sum(!is.nan(test_doses) + !is.infinite(test_doses)) == 0){
#   lines( c(fit$bmd[1],fit$bmd[1]),c(0,temp_fit(fit$bmd[1])))
#   lines( c(fit$bmd[2],fit$bmd[2]),c(0,temp_fit(fit$bmd[2])))
#   lines( c(fit$bmd[3],fit$bmd[3]),c(0,temp_fit(fit$bmd[3])))
# }
#
# Adding density
# Object 3 - Density object - In Shiny we can on / off this
# Density - Polygon/Other option?
if (BMD_DENSITY ==TRUE){
Dens =  density(temp,cut=c(max(doses)))
# what is this 0.4 means? Scale?
Dens$y = Dens$y/max(Dens$y) * max(probs)*0.4
temp = which(Dens$x < max(doses))
D1_y = Dens$y[temp]
D1_x = Dens$x[temp]
#geom ploygon
# geom_polygon(aes(x=c(test_doses,test_doses[length(test_doses):1]),y=c(uq,lq[length(test_doses):1])), fill="blue",alpha=0.1)
#polygon(c(0,D1_x,max(doses)),c(0,D1_y,0),col = alphablend(col=density_col,0.2),border =alphablend(col=density_col,0.2))
out5<-out4+geom_polygon(aes(x=c(0,D1_x,max(doses)),y=c(0,D1_y,0)), fill = "lightblue", alpha=0.7)
return(out5)
}
# Already reflected from above
#points(doses,probs)
#arrows(x0=doses, y0=lerror, x1=doses,
#       y1=uerror, code=3, angle=90, length=0.1)
out4
}
# Single model fitting
A_single_mcmc<-single_dichotomous_fit(mData[,1],mData[,2],mData[,3], model_type="hill",fit_type="mcmc")
.plot.BMDdich_fit_MCMC(A_single_mcmc)
A_single_laplace = single_dichotomous_fit(mData[,1],mData[,2],mData[,3],model_type="hill",fit_type = "laplace")
.plot.BMDdich_fit_maximized(A_single_laplace)
# Single model fitting
A_single_mcmc<-single_dichotomous_fit(mData[,1],mData[,2],mData[,3], model_type="hill",fit_type="mcmc")
.plot.BMDdich_fit_MCMC(A_single_mcmc)
A_single_laplace = single_dichotomous_fit(mData[,1],mData[,2],mData[,3],model_type="hill",fit_type = "laplace")
.plot.BMDdich_fit_maximized(A_single_laplace)
# Single model fitting
A_single_mcmc<-single_dichotomous_fit(mData[,1],mData[,2],mData[,3], model_type="hill",fit_type="mcmc")
.plot.BMDdich_fit_MCMC(A_single_mcmc)
A_single_laplace = single_dichotomous_fit(mData[,1],mData[,2],mData[,3],model_type="hill",fit_type = "laplace")
.plot.BMDdich_fit_maximized(A_single_laplace)
.plot.BMDdich_fit_maximized <- function(fit,fit_type,qprob=0.05,...){
density_col="red"
credint_col="lightblue1"
if (qprob < 0 || qprob > 0.5){
stop( "Quantile probability must be between 0 and 0.5")
}
probs <- (0.5+fit$data[,2,drop=T])/(1.0 + fit$data[,3,drop=T])
se <- sqrt(probs*(1-probs)/fit$data[,3,drop=T])
doses = fit$data[,1,drop=T]
uerror <- apply(cbind(probs*0+1,probs+se),1,min)
lerror <- apply(cbind(probs*0,probs-se),1,max)
dose = c(doses,doses)
Response = c(uerror,lerror)
#plot(dose,Response,type='n',main=fit$full_model...)
out<-ggplot()+
geom_errorbar(aes(x=doses, ymin=lerror, ymax=uerror),color="grey")+xlim(c(min(dose),max(dose)))+ylim(c(0,1))+labs(x="Dose", y="Proportion",title=paste(fit$full_model, fit_type,sep=",  Fit Type: " ))+theme_minimal()
test_doses <- seq(min(doses),max(doses)*1.03,(max(doses)*1.03-min(doses))/100)
if (fit$model=="hill"){
#fit$parameters[1] = .logit(fit$parameters[1])
#fit$parameters[2] = .logit(fit$parameters[2])
me <- .dich_hill_f(fit$parameters, d=test_doses)
}
if (fit$model=="gamma"){
#fit$parameters[1] = .logit(fit$parameters[1])
me <- .dich_gamma_f(fit$parameters, d=test_doses)
}
if (fit$model=="logistic"){
me <- .dich_logist_f(fit$parameters, d=test_doses)
}
if (fit$model=="log-logistic"){
#fit$parameters[1] = logit(fit$parameters[1])
me <- .dich_llogist_f(fit$parameters, d=test_doses)
}
if (fit$model=="probit"){
#fit$parameters[1] = .logit(fit$parameters[1])
print
me <- .dich_probit_f(fit$parameters, d=test_doses)
}
if (fit$model=="log-probit"){
#fit$parameters[1] = .logit(fit$parameters[1])
me <- .dich_lprobit_f(fit$parameters, d=test_doses)
}
if (fit$model=="multistage"){
#fit$parameters[1] = .logit(fit$parameters[1])
me <- .dich_multistage_f(fit$parameters, d=test_doses)
}
if (fit$model=="qlinear"){
#fit$parameters[1] = .logit(fit$parameters[1])
me <- .dich_qlinear_f(fit$parameters, d=test_doses)
}
if (fit$model=="weibull"){
#fit$parameters[1] = .logit(fit$parameters[1])
me <- .dich_weibull_f(fit$parameters, d=test_doses)
}
temp_fit<-splinefun(test_doses,me)
#BMD Estimates fit - MLE/Laplace why they don't have it yet..?
out2<-out+geom_smooth(aes(x=test_doses,y=me),col="blue")+geom_point(aes(x=doses,y=probs))
out3<-out2+geom_segment(aes(x=fit$bmd, y=temp_fit(x=fit$bmd), xend=fit$bmd, yend=0), color="Red")
temp_fit <- splinefun(test_doses,me)
#
# if(sum(!is.nan(test_doses) + !is.infinite(test_doses)) == 0){
#   lines( c(fit$bmd[1],fit$bmd[1]),c(0,temp_fit(fit$bmd[1])))
#   lines( c(fit$bmd[2],fit$bmd[2]),c(0,temp_fit(fit$bmd[2])))
#   lines( c(fit$bmd[3],fit$bmd[3]),c(0,temp_fit(fit$bmd[3])))
# }
#
#
#This CDF needs to be fixed
out3
# Adding CDF part should be fixed
# temp <- fit$bmd_dist
# temp <- temp[!is.infinite(temp[,1]),]
# temp <- temp[!is.nan(temp[,1]),]
# cdf_rows = nrow(temp)
# a = temp[,1]
# b = temp[,2]
# b = b[(!is.infinite(a))*(!is.na(a))*(!is.nan(a)) == 1]
# a = a[(!is.infinite(a))*(!is.na(a))*(!is.nan(a)) == 1]
# ta = a
# tb = ta*0
# a = c(min(a)*0.9,a,max(a)*1.1)
# b = c(0,b,1.0)
# cdf_est <- splinefun(a,b)
#
# for(i in 1:length(ta)){
#   tb[i] = -qchisq(abs(0.5-cdf_est(ta[i])),df=1)*0.5 #approximate the profile
# }
# tb = tb - min(tb)
# tb = tb/(max(tb))*max(probs)*0.4
# tb[1] = 0; tb[length(tb)] = 0;
# polygon(ta,tb,col = alphablend(col="red",0.2),border =alphablend(col="red",0.2))
#
# points(doses,probs,...)
# arrows(x0=doses, y0=lerror, x1=doses,
#        y1=uerror, code=3, angle=90, length=0.1)
#
#
#
}
.plot.BMDdich_fit_maximized(A_single_laplace)
A_single_laplace = single_dichotomous_fit(mData[,1],mData[,2],mData[,3],model_type="hill",fit_type = "laplace")
.plot.BMDdich_fit_maximized(A_single_laplace)
.plot.BMDdich_fit_maximized <- function(fit,fit_type="laplace",qprob=0.05,...){
density_col="red"
credint_col="lightblue1"
if (qprob < 0 || qprob > 0.5){
stop( "Quantile probability must be between 0 and 0.5")
}
probs <- (0.5+fit$data[,2,drop=T])/(1.0 + fit$data[,3,drop=T])
se <- sqrt(probs*(1-probs)/fit$data[,3,drop=T])
doses = fit$data[,1,drop=T]
uerror <- apply(cbind(probs*0+1,probs+se),1,min)
lerror <- apply(cbind(probs*0,probs-se),1,max)
dose = c(doses,doses)
Response = c(uerror,lerror)
#plot(dose,Response,type='n',main=fit$full_model...)
out<-ggplot()+
geom_errorbar(aes(x=doses, ymin=lerror, ymax=uerror),color="grey")+xlim(c(min(dose),max(dose)))+ylim(c(0,1))+labs(x="Dose", y="Proportion",title=paste(fit$full_model, fit_type,sep=",  Fit Type: " ))+theme_minimal()
test_doses <- seq(min(doses),max(doses)*1.03,(max(doses)*1.03-min(doses))/100)
if (fit$model=="hill"){
#fit$parameters[1] = .logit(fit$parameters[1])
#fit$parameters[2] = .logit(fit$parameters[2])
me <- .dich_hill_f(fit$parameters, d=test_doses)
}
if (fit$model=="gamma"){
#fit$parameters[1] = .logit(fit$parameters[1])
me <- .dich_gamma_f(fit$parameters, d=test_doses)
}
if (fit$model=="logistic"){
me <- .dich_logist_f(fit$parameters, d=test_doses)
}
if (fit$model=="log-logistic"){
#fit$parameters[1] = logit(fit$parameters[1])
me <- .dich_llogist_f(fit$parameters, d=test_doses)
}
if (fit$model=="probit"){
#fit$parameters[1] = .logit(fit$parameters[1])
print
me <- .dich_probit_f(fit$parameters, d=test_doses)
}
if (fit$model=="log-probit"){
#fit$parameters[1] = .logit(fit$parameters[1])
me <- .dich_lprobit_f(fit$parameters, d=test_doses)
}
if (fit$model=="multistage"){
#fit$parameters[1] = .logit(fit$parameters[1])
me <- .dich_multistage_f(fit$parameters, d=test_doses)
}
if (fit$model=="qlinear"){
#fit$parameters[1] = .logit(fit$parameters[1])
me <- .dich_qlinear_f(fit$parameters, d=test_doses)
}
if (fit$model=="weibull"){
#fit$parameters[1] = .logit(fit$parameters[1])
me <- .dich_weibull_f(fit$parameters, d=test_doses)
}
temp_fit<-splinefun(test_doses,me)
#BMD Estimates fit - MLE/Laplace why they don't have it yet..?
out2<-out+geom_smooth(aes(x=test_doses,y=me),col="blue")+geom_point(aes(x=doses,y=probs))
out3<-out2+geom_segment(aes(x=fit$bmd, y=temp_fit(x=fit$bmd), xend=fit$bmd, yend=0), color="Red")
temp_fit <- splinefun(test_doses,me)
#
# if(sum(!is.nan(test_doses) + !is.infinite(test_doses)) == 0){
#   lines( c(fit$bmd[1],fit$bmd[1]),c(0,temp_fit(fit$bmd[1])))
#   lines( c(fit$bmd[2],fit$bmd[2]),c(0,temp_fit(fit$bmd[2])))
#   lines( c(fit$bmd[3],fit$bmd[3]),c(0,temp_fit(fit$bmd[3])))
# }
#
#
#This CDF needs to be fixed
out3
# Adding CDF part should be fixed
# temp <- fit$bmd_dist
# temp <- temp[!is.infinite(temp[,1]),]
# temp <- temp[!is.nan(temp[,1]),]
# cdf_rows = nrow(temp)
# a = temp[,1]
# b = temp[,2]
# b = b[(!is.infinite(a))*(!is.na(a))*(!is.nan(a)) == 1]
# a = a[(!is.infinite(a))*(!is.na(a))*(!is.nan(a)) == 1]
# ta = a
# tb = ta*0
# a = c(min(a)*0.9,a,max(a)*1.1)
# b = c(0,b,1.0)
# cdf_est <- splinefun(a,b)
#
# for(i in 1:length(ta)){
#   tb[i] = -qchisq(abs(0.5-cdf_est(ta[i])),df=1)*0.5 #approximate the profile
# }
# tb = tb - min(tb)
# tb = tb/(max(tb))*max(probs)*0.4
# tb[1] = 0; tb[length(tb)] = 0;
# polygon(ta,tb,col = alphablend(col="red",0.2),border =alphablend(col="red",0.2))
#
# points(doses,probs,...)
# arrows(x0=doses, y0=lerror, x1=doses,
#        y1=uerror, code=3, angle=90, length=0.1)
#
#
#
}
A_single_laplace = single_dichotomous_fit(mData[,1],mData[,2],mData[,3],model_type="hill",fit_type = "laplace")
.plot.BMDdich_fit_maximized(A_single_laplace)
temp_house
temp_house[,1]
library("gapminder")   # dataset with country, may need to install this if it is not available
library(ggdist)
library(dplyr)
library(tidyr)
library(distributional)
library(ggdist)
library(ggplot2)
library(cowplot)  # annotate, arrange, mix plots
install.packages('ggdist')
library(ggdist)
library(ggplot2)
install.packages('cowplot')
library(ggdist)
library(dplyr)
library(tidyr)
library(distributional)
library(ggdist)
library(ggplot2)
library(cowplot)  # annotate, arrange, mix plots
set.seed(1234)
df = tribble(
~group, ~subgroup, ~value,
"a",          "h", rnorm(1000, mean = 5),
"b",          "h", rnorm(1000, mean = 7, sd = 1.5),
"c",          "h", rnorm(1000, mean = 8),
"c",          "i", rnorm(1000, mean = 9),
"c",          "j", rnorm(1000, mean = 7)
) %>%
unnest(value)
# stat_eye == violins .............
df %>%
ggplot(aes(y = group, x = value)) +
stat_eye() +
ggtitle("stat_eye()")
# half_eye == density
df %>%
ggplot(aes(y = group, x = value)) +
stat_halfeye() +
ggtitle("stat_halfeye()")
# more control .............................
p = df %>%
ggplot(aes(x = group, y = value)) +
panel_border()     # cowplot::panel_border
plot_grid(ncol = 3, align = "hv",
p + stat_eye(side = "left") + labs(title = "stat_eye()", subtitle = "side = 'left'"),
p + stat_eye(side = "both") + labs(subtitle = "side = 'both'"),
p + stat_eye(side = "right")  + labs(subtitle = "side = 'right'")
)
# more from the vignette .............
#    distributional::dist_beta
data.frame(alpha = seq(5, 100, length.out = 10)) %>%
ggplot(aes(y = "", dist = dist_beta(alpha, 10), color = alpha)) +
stat_dist_slab(fill = NA) +
coord_cartesian(expand = FALSE) +
scale_color_viridis_c() +
labs(
title = "stat_dist_slab()",
subtitle = "aes(dist = dist_beta(alpha, 10), color = alpha)",
x = "Beta(alpha,10) distribution",
y = NULL
)
p = df %>%
ggplot(aes(x = group, y = value)) +
panel_border()
# more from the vignette .............
#    distributional::dist_beta
data.frame(alpha = seq(5, 100, length.out = 10)) %>%
ggplot(aes(y = "", dist = dist_beta(alpha, 10), color = alpha)) +
stat_dist_slab(fill = NA) +
coord_cartesian(expand = FALSE) +
scale_color_viridis_c() +
labs(
title = "stat_dist_slab()",
subtitle = "aes(dist = dist_beta(alpha, 10), color = alpha)",
x = "Beta(alpha,10) distribution",
y = NULL
)
p = df %>%
ggplot(aes(x = group, y = value)) +
panel_border()
ph = df %>%
ggplot(aes(y = group, x = value)) +
panel_border()
plot_grid(ncol = 2, align = "hv",
p + stat_histinterval() + labs(title = "stat_histinterval()", subtitle = "horizontal"),
ph + stat_histinterval() + labs(subtitle = "vertical")
)
plot_grid(ncol = 2, align = "hv",
ph + stat_histinterval(slab_color = "gray45", outline_bars = FALSE) +
labs(title = "stat_histinterval", subtitle = "outline_bars = FALSE (default)"),
ph + stat_histinterval(slab_color = "gray45", outline_bars = TRUE) +
labs(subtitle = "outline_bars = TRUE")
)
# cumulative distribution functions ....
p = df %>%
ggplot(aes(x = group, y = value)) +
panel_border()
ph = df %>%
ggplot(aes(y = group, x = value)) +
panel_border()
plot_grid(ncol = 2, align = "hv",
p + stat_ccdfinterval() + labs(title = "stat_ccdfinterval()", subtitle = "vertical"),
ph + stat_ccdfinterval() + labs(subtitle = "horizontal"),
p + stat_cdfinterval() + labs(title = "stat_cdfinterval()", subtitle = "vertical"),
ph + stat_cdfinterval()  + labs(subtitle = "horizontal")
)
# gradients .........................
df %>%
ggplot(aes(x = group, y = value, fill = subgroup)) +
stat_gradientinterval(position = "dodge") +
labs(title = "stat_gradientinterval(position = 'dodge')")
set.seed(86753092)
vec1 <- c(rnorm(n=400,mean=54,sd=10),rnorm(n=200,mean=79,sd=8))
vec2 <- c(rnorm(n=600, mean=62.75275, sd=15.28787))
vec3 <- rgamma(n=600, shape = 16.8489, scale=3.724442)
vec4 <- runif(n=600, min=32.77338, max=92.73212)
myDF <- data.frame(group=rep(c(1,2,3,4),
c(600,600,600,600)),
response = c(vec1, vec2, vec3, vec4))
myDF <- myDF %>%
mutate(fgroup=factor(group,
labels = c("bimodal", "normal", "gamma", "uniform")))
# stat_eye for our simulation data .............
myDF %>%
ggplot(aes(y = fgroup, x = response)) +
stat_eye() +
ggtitle("stat_eye for 404/504 class examples")
# stat_halfeye for our simulation data .............
myDF %>%
ggplot(aes(y = fgroup, x = response)) +
stat_halfeye() +
ggtitle("stat_halfeye for 404/504 class examples")
# more control ...........................
p <- myDF %>%
ggplot(aes(x = fgroup, y = response)) +
panel_border()
plot_grid(ncol = 3, align = "hv",
p + stat_eye(side = "left") + labs(title = "stat_eye()", subtitle = "side = 'left'"),
p + stat_eye(side = "both") + labs(subtitle = "side = 'both'"),
p + stat_eye(side = "right")  + labs(subtitle = "side = 'right'")
)
# gradients .........................
myDF %>%
ggplot(aes(x = fgroup, y = response,
fill = fgroup)) +
stat_gradientinterval(position = "dodge") +
labs(title = "stat_gradientinterval(position = 'dodge')") +
guides(fill=FALSE) +
theme_minimal()
plot_grid(ncol = 3, align = "hv",
p + stat_eye(side = "left") + labs(title = "stat_eye()", subtitle = "side = 'left'"),
p + stat_eye(side = "both") + labs(subtitle = "side = 'both'"),
p + stat_eye(side = "right")  + labs(subtitle = "side = 'right'")
)
