{
for(i in 1:nrow(ties))
{
correction <- correction + (ties$count[i] * (ties$numTies[i]^3 - ties$numTies[i]))
}
}
}
## rankings ... lowest value gets rank of 1
ranks <- as.data.frame(table(ex$numeric_value))
names(ranks) <- c('value', 'count')
ranks$value  <- as.numeric(as.character(ranks$value))
weights <- NULL
for(i in 1:nrow(ranks))
{
if(ranks$count[i]==1)
{
weights <- c(weights, sum(ranks[1:i,'count']))	## if a singleton, just add up previous number of values to get rank
} else
{
start <- sum(ranks[1:i-1,'count'])		## get starting point (previous rank)
ranknum <- 0
for(j in 1:ranks$count[i])
{
ranknum <- ranknum + start + j
}
ranknum <- ranknum / ranks$count[i]
weights <- c(weights, ranknum)
}
}
ranks2 <- cbind(ranks, weights)
names(ranks2)[3] <- 'rank'
## populate ex with ranks
## need to recast as numeric, may crash otherwise (weird!)
ex$numeric_value <- as.character(ex$numeric_value)
ex$numeric_value <- as.numeric(ex$numeric_value)
ex2 <- merge(ex, ranks2, by.x='numeric_value', by.y='value', all.x=TRUE)
ex2 <- ex2[order(ex2$dose2),]
rankMeans <- summaryBy(rank ~ dose + dose2, data=ex2, FUN=mean)
## enumerate doseCount
count <- 0
for(i in 1:nrow(rankMeans))
{
rankMeans$doseCount[i] <- count
count <- count + 1
}
## find variance
V  <- (nrow(ex) * (nrow(ex) + 1))/12
## get crit values ... warnings are for CONTROL group, which is fine
prob05 <- qnorm(1 - (.05 / (2 * max(rankMeans$doseCount) )))
prob01 <- qnorm(1 - (.01 / (2 * max(rankMeans$doseCount) )))
## loop through doses, determine significance
rankMeans$DUNSIGN <- 0
rankMeans$num <- 0
rankMeans$mult_comp_signif <- 0
for(i in 2:nrow(rankMeans))		## skip CONTROL (first line)
{
## populate DUNSIGN (flag for mean of treatment group being greater than control group)
if(rankMeans$rank.mean[i] >= rankMeans$rank.mean[1])
{
rankMeans$DUNSIGN[i] <- 0
} else
{
rankMeans$DUNSIGN[i] <- -1
}
## find significance level
rankdiff <- abs(rankMeans$rank.mean[i] - rankMeans$rank.mean[1])
num   <- nrow(subset(ex2, dose == rankMeans$dose2[i]))
comp2 <- V * ( (1/num) + 1/nrow(subset(ex2, dose2 == rankMeans$dose2[1])) )
comp2 <- (comp2 * (1 - correction / (nrow(ex2)^3 - nrow(ex2))))^.5
sig05 <- rankdiff - (prob05 * comp2)
sig01 <- rankdiff - (prob01 * comp2)
signific <- 0
if(sig05 > 0)
{
signific <- 1
}
if(sig01 > 0)
{
signific <- 2
}
rankMeans$num[i] <- num
rankMeans$mult_comp_signif[i] <- signific
}
results <- rankMeans
results$sex  <- ex2$sex[1]
results$endpoint <- ex2$endpoint[1]
results$generation <- ex2$generation[1]
results$selection <- ex2$selection[1]
results$litter_name <- ex2$litter_name[1]
results$phase_type  <- ex2$phase_type[1]
results$phase_time  <- ex2$phase_time[1]
results$phase_start  <- ex2$phase_start[1]
results$phase_end  <- ex2$phase_end[1]
dunn_results <- rbind(dunn_results, results)
}
}
}
## check for existence
if(!is.null(dunn_results))
{
dunn_results <- dunn_results[,c('sex', 'endpoint', 'generation', 'selection', 'litter_name', 'phase_type', 'phase_time', 'phase_start', 'phase_end', 'dose', 'dose2', 'mult_comp_signif')]
## coerce into same format as SHIRLEY results
dunn_results$mult_comp_test <- 'DUNN'
dunn_results <- dunn_results[order(dunn_results$sex, dunn_results$endpoint, dunn_results$generation, dunn_results$selection, dunn_results$litter_name, dunn_results$phase_type, dunn_results$phase_time, dunn_results$phase_start, dunn_results$phase_end, dunn_results$dose2),]
## cut out controls
dunn_results <- subset(dunn_results, dose2 != 0)
}
return(dunn_results)
}
DUNN(jonck_data=joncB, dunn_data=jonck_input.shirley_dunn)
joncB =  JONCK(jonck_input.shirley_dunn,pair="Shirley")
## -----------------------------------------------------------
## JONCKHEERE'S TEST - run for each sex/organ combination
## ----------------Changelog----------------------------------
## Released:
## [1.1.0] - 08/07/2019. Jira ticket:CEBSPROV-5301
## Changed
## Fixes for Kendall test. Set Exact = FALSE
## -----------------------------------------------------------
JONCK <- function(jdata, pair)
{
jonck <- NULL
##KRS - added "numeric_value" on the left hand side
jonck_list <- summaryBy(numeric_value~ sex + endpoint + generation + selection + litter_name + phase_type + phase_time + phase_start + phase_end, data=jdata, FUN=length)
jdata <- fix_rounding(jdata)
## may create WARNINGS when ties are present
for(i in 1:nrow(jonck_list))
{
jsex <- jonck_list$sex[i]
point <- jonck_list$endpoint[i]
gen <- jonck_list$generation[i]
sel <- jonck_list$selection[i]
lit <- jonck_list$litter_name[i]
##KRS - changed "phase" to "phasetype"
phasetype <- jonck_list$phase_type[i]
time <- jonck_list$phase_time[i]
start <- jonck_list$phase_start[i]
end <- jonck_list$phase_end[i]
##KRS - changed "phase" to "phasetype"
tempdata <- subset(jdata, sex==jsex & endpoint==point & generation==gen & selection==sel & litter_name==lit & phase_type==phasetype & phase_time==time & phase_start==start & phase_end==end)
## make sure there is more than ONE record for gender i
if(nrow(tempdata) > 1)
{
## make sure variance is not zero (creates error) and control is present
if((length(unique(tempdata$numeric_value)) > 1) & (0 %in% tempdata$dose))
{
stat <- cor.test(tempdata$dose2, tempdata$numeric_value, method="kendall", exact=FALSE)
##KRS - changed "phase" to "phasetype"
jline <- c(jsex, point, gen, sel, lit, phasetype, time, start, end, stat$estimate, stat$p.value)
if(!is.na(jline[10]))		## there may be NULLS we want to skip (ex: only 2 records both control)
{
jonck <- rbind(jonck, jline)
}
}
}
}
## check for existence
if(!is.null(jonck))
{
rownames(jonck) <- NULL
jonck <- as.data.frame(jonck)
names(jonck) <- c('sex', 'endpoint', 'generation', 'selection', 'litter_name', 'phase_type', 'phase_time', 'phase_start', 'phase_end', 'tau', 'pvalue')
jonck$tau <- as.numeric(as.character(jonck$tau))
jonck$pvalue <- as.numeric(as.character(jonck$pvalue))
##KRS - changed "as.numeric(jonck$phase_time)" to "as.numeric(as.character(jonck$phase_time)), also for phase_start and phase_end
jonck$phase_time <- as.numeric(as.character(jonck$phase_time))
jonck$phase_start <- as.numeric(as.character(jonck$phase_start))
jonck$phase_end <- as.numeric(as.character(jonck$phase_end))
jonck <- jonck[order(jonck$sex, jonck$endpoint, jonck$generation, jonck$selection, jonck$litter_name, jonck$phase_type, jonck$phase_time, jonck$phase_start, jonck$phase_end), ]
## need to remove nulls before moving to subsequent stat tests
jonck$phase_time <- ifelse(is.na(jonck$phase_time), '', jonck$phase_time)
jonck$phase_start <- ifelse(is.na(jonck$phase_start), '', jonck$phase_start)
jonck$phase_end <- ifelse(is.na(jonck$phase_end), '', jonck$phase_end)
## add in SAS logic to JONCK dataset (lines 170 - 188)
jonck$trend <- ifelse(jonck$tau < 0, jonck$pvalue * -1, jonck$pvalue)
jonck$prbjstar <- round_any(abs(jonck$pvalue), .001)
## round pvals
jonck$prbjstar <- round2(jonck$prbjstar, 4)
if(pair=='Williams') { jonck$mult_comp_test <- ifelse(jonck$prbjstar <= .01, 'WILLIAMS', 'DUNNETT')	}
if(pair=='Shirley') { jonck$mult_comp_test <- ifelse(jonck$prbjstar <= .01, 'SHIRLEY', 'DUNN')	}
}
return(jonck)
}
joncB =  JONCK(jonck_input.shirley_dunn,pair="Shirley")
DUNN(jonck_data=joncB, dunn_data=jonck_input.shirley_dunn)
DUNN(jonck_data=joncB, dunn_data=jonck_input.shirley_dunn)
NTP_DUNN(numeric_value~ sex + endpoint ,
dunn_data =jonck_input.shirley_dunn )
joncA =  NTP_JONCK ( numeric_value~ sex + endpoint ,
data = jonck_input.shirley_dunn)
joncA
print(joncA,digits = 3)
print(joncA,digits = 2)
plot(AA_l) + scale_x_continuous(trans="psuedolog")
joncA =  NTP_JONCK ( numeric_value ~ sex + endpoint ,
data = jonck_input.shirley_dunn,pair="Shirley")
joncA
joncA %>% filter(mul_comp_test=="SHIRLEY")
joncA %>% filter(mult_comp_test=="SHIRLEY")
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "mcmc",BMD_TYPE = 'sd',BMR = 1)
setwd("~/Documents/r_software/RBMDS/ToxicR/src/code_base")
load("~/Documents/r_software/RBMDS/Simulation/Non-Parametric/NP_invGaussian_g_5_sim_3.Rdata")
y = sim_data[jj,]
print(jj)
jj = 1
y = sim_data[jj,]
print(jj)
library(ToxicR)
model_list  = data.frame(model_list = c(rep("hill",2),rep("exp-3",3),rep("exp-5",3),rep("power",2)),
distribution_list =  c(c("normal","normal-ncv"),rep(c("normal","normal-ncv","lognormal"),2),
"normal", "normal-ncv"))
model_list2 = data.frame(model_list = c(rep("hill",1),rep("exp-3",1),rep("exp-5",1),rep("power",1)),
distribution_list =  c(rep(c("normal"),4)))
prior_list_one = list()
for (i in 1:nrow(model_list)){
t_prior = bayesian_prior_continuous_default(model_list$model_list[i],model_list$distribution_list[i])
if(model_list$distribution_list[i] == "lognormal"){
t_prior$priors[nrow(t_prior$priors),2] = log(var(log(y)))
}else{
if (model_list$distribution_list[i] == "normal"){
t_prior$priors[nrow(t_prior$priors),2]   = log(var(y))
}else{
t_prior$priors[nrow(t_prior$priors),2]   = log(mean(y)/var(y))
}
}
prior_list_one[[i]] = create_continuous_prior(t_prior,model_list$model_list[i],model_list$distribution_list[i])
}
prior_list_two = list()
for (i in 1:nrow(model_list2)){
t_prior = bayesian_prior_continuous_default(model_list2$model_list[i],model_list2$distribution_list[i])
if(model_list$distribution_list[i] == "lognormal"){
t_prior$priors[nrow(t_prior$priors),2] = log(var(log(y)))
}else{
t_prior$priors[nrow(t_prior$priors),2]   = log(var(y))
}
prior_list_two[[i]] = create_continuous_prior(t_prior,model_list2$model_list[i],model_list2$distribution_list[i])
}
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "mcmc",BMD_TYPE = 'sd',BMR = 1)
plot(AA_;)
plot(AA_l)
.95*75
x <- rnorm(200000)
xt <- x[x < 1]
length(xt)/length(x)
p1 = length(xt)/length(x)
r <- sort(xt)
t <- r[floor(0.99*length(r)]
t <- r[floor(0.99*length(r))]
pnorm(t)
0.99*p1
t <- r[floor(0.93*length(r))]
pnorm(t)
0.93*p1
t <- r[floor(0.05*length(r))]
floor(t)
pnorm(t)
0.05*p1
.5/0.p1
.5/p1
t <- r[floor(.5/p1*length(r))]
pnorm(t)
AA_l$bmd
library(ToxicR)
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "mcmc",BMD_TYPE = 'sd',BMR = 1)
AA_l$bmd
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "laplace",BMD_TYPE = 'sd',BMR = 1)
AA_l$bmd
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "mcmc",BMD_TYPE = 'sd',BMR = 1)
AA_l$bmd
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "mcmc",BMD_TYPE = 'sd',BMR = 1)
AA_l$bmd
plot(AA_l)
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "mcmc",BMD_TYPE = 'sd',BMR = 1,samples = 40000)
AA_l$bmd
jj = 3
y = sim_data[jj,]
print(jj)
library(ToxicR)
prior_list_one = list()
for (i in 1:nrow(model_list)){
t_prior = bayesian_prior_continuous_default(model_list$model_list[i],model_list$distribution_list[i])
if(model_list$distribution_list[i] == "lognormal"){
t_prior$priors[nrow(t_prior$priors),2] = log(var(log(y)))
}else{
if (model_list$distribution_list[i] == "normal"){
t_prior$priors[nrow(t_prior$priors),2]   = log(var(y))
}else{
t_prior$priors[nrow(t_prior$priors),2]   = log(mean(y)/var(y))
}
}
prior_list_one[[i]] = create_continuous_prior(t_prior,model_list$model_list[i],model_list$distribution_list[i])
}
prior_list_two = list()
for (i in 1:nrow(model_list2)){
t_prior = bayesian_prior_continuous_default(model_list2$model_list[i],model_list2$distribution_list[i])
if(model_list$distribution_list[i] == "lognormal"){
t_prior$priors[nrow(t_prior$priors),2] = log(var(log(y)))
}else{
t_prior$priors[nrow(t_prior$priors),2]   = log(var(y))
}
prior_list_two[[i]] = create_continuous_prior(t_prior,model_list2$model_list[i],model_list2$distribution_list[i])
}
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "mcmc",BMD_TYPE = 'sd',BMR = 1,samples = 40000)
plot(AA_l)
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "laplace",BMD_TYPE = 'sd',BMR = 1,samples = 40000)
plot(AA_l)
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "laplace",BMD_TYPE = 'sd',BMR = 1,samples = 40000)
plot(AA_l)
BB_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_two,
fit_type = "laplace",BMD_TYPE = 'sd',BMR = 1)
BB_l
AA_l
AA_l$bmd
BB_l$bmd
for (jj in 1:40){#nrow(sim_data)){
#print(sprintf("File:%d Iter:%d.",ii,jj))
###############################################################################
y = sim_data[jj,]
print(jj)
library(ToxicR)
prior_list_one = list()
for (i in 1:nrow(model_list)){
t_prior = bayesian_prior_continuous_default(model_list$model_list[i],model_list$distribution_list[i])
if(model_list$distribution_list[i] == "lognormal"){
t_prior$priors[nrow(t_prior$priors),2] = log(var(log(y)))
}else{
if (model_list$distribution_list[i] == "normal"){
t_prior$priors[nrow(t_prior$priors),2]   = log(var(y))
}else{
t_prior$priors[nrow(t_prior$priors),2]   = log(mean(y)/var(y))
}
}
prior_list_one[[i]] = create_continuous_prior(t_prior,model_list$model_list[i],model_list$distribution_list[i])
}
prior_list_two = list()
for (i in 1:nrow(model_list2)){
t_prior = bayesian_prior_continuous_default(model_list2$model_list[i],model_list2$distribution_list[i])
if(model_list$distribution_list[i] == "lognormal"){
t_prior$priors[nrow(t_prior$priors),2] = log(var(log(y)))
}else{
t_prior$priors[nrow(t_prior$priors),2]   = log(var(y))
}
prior_list_two[[i]] = create_continuous_prior(t_prior,model_list2$model_list[i],model_list2$distribution_list[i])
}
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "laplace",BMD_TYPE = 'sd',BMR = 1,samples = 40000)
print( as.numeric(sprintf("%1.3f",AA_l$posterior_probs)))
BB_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_two,
fit_type = "laplace",BMD_TYPE = 'sd',BMR = 1)
cat(sprintf(" %f  %f \n", AA_l$bmd,BB_l$bmd))
print( as.numeric(sprintf("%1.3f",AA_l$posterior_probs)))
################################################################################
}
for (jj in 1:40){#nrow(sim_data)){
#print(sprintf("File:%d Iter:%d.",ii,jj))
###############################################################################
y = sim_data[jj,]
print(jj)
library(ToxicR)
prior_list_one = list()
for (i in 1:nrow(model_list)){
t_prior = bayesian_prior_continuous_default(model_list$model_list[i],model_list$distribution_list[i])
if(model_list$distribution_list[i] == "lognormal"){
t_prior$priors[nrow(t_prior$priors),2] = log(var(log(y)))
}else{
if (model_list$distribution_list[i] == "normal"){
t_prior$priors[nrow(t_prior$priors),2]   = log(var(y))
}else{
t_prior$priors[nrow(t_prior$priors),2]   = log(mean(y)/var(y))
}
}
prior_list_one[[i]] = create_continuous_prior(t_prior,model_list$model_list[i],model_list$distribution_list[i])
}
prior_list_two = list()
for (i in 1:nrow(model_list2)){
t_prior = bayesian_prior_continuous_default(model_list2$model_list[i],model_list2$distribution_list[i])
if(model_list$distribution_list[i] == "lognormal"){
t_prior$priors[nrow(t_prior$priors),2] = log(var(log(y)))
}else{
t_prior$priors[nrow(t_prior$priors),2]   = log(var(y))
}
prior_list_two[[i]] = create_continuous_prior(t_prior,model_list2$model_list[i],model_list2$distribution_list[i])
}
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "laplace",BMD_TYPE = 'sd',BMR = 1,samples = 40000)
print( as.numeric(sprintf("%1.3f",AA_l$posterior_probs)))
BB_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_two,
fit_type = "laplace",BMD_TYPE = 'sd',BMR = 1)
cat(sprintf(" %f  %f \n", AA_l$bmd,BB_l$bmd))
print( as.numeric(sprintf("%1.3f",AA_l$posterior_probs)))
################################################################################
}
for (jj in 1:40){#nrow(sim_data)){
#print(sprintf("File:%d Iter:%d.",ii,jj))
###############################################################################
y = sim_data[jj,]
print(jj)
library(ToxicR)
prior_list_one = list()
for (i in 1:nrow(model_list)){
t_prior = bayesian_prior_continuous_default(model_list$model_list[i],model_list$distribution_list[i])
if(model_list$distribution_list[i] == "lognormal"){
t_prior$priors[nrow(t_prior$priors),2] = log(var(log(y)))
}else{
if (model_list$distribution_list[i] == "normal"){
t_prior$priors[nrow(t_prior$priors),2]   = log(var(y))
}else{
t_prior$priors[nrow(t_prior$priors),2]   = log(mean(y)/var(y))
}
}
prior_list_one[[i]] = create_continuous_prior(t_prior,model_list$model_list[i],model_list$distribution_list[i])
}
prior_list_two = list()
for (i in 1:nrow(model_list2)){
t_prior = bayesian_prior_continuous_default(model_list2$model_list[i],model_list2$distribution_list[i])
if(model_list$distribution_list[i] == "lognormal"){
t_prior$priors[nrow(t_prior$priors),2] = log(var(log(y)))
}else{
t_prior$priors[nrow(t_prior$priors),2]   = log(var(y))
}
prior_list_two[[i]] = create_continuous_prior(t_prior,model_list2$model_list[i],model_list2$distribution_list[i])
}
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "mcmc",BMD_TYPE = 'sd',BMR = 1)
print( as.numeric(sprintf("%1.3f",AA_l$posterior_probs)))
BB_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_two,
fit_type = "laplace",BMD_TYPE = 'sd',BMR = 1)
cat(sprintf(" %f  %f \n", AA_l$bmd,BB_l$bmd))
print( as.numeric(sprintf("%1.3f",AA_l$posterior_probs)))
################################################################################
}
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "mcmc",BMD_TYPE = 'hybrid',BMR = 0.1)
AA_l$bmd
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "mcmc",BMD_TYPE = 'hybrid',BMR = 0.05,point_p = 0.025)
AA_l$bmd
BB_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_two,
fit_type = "laplace",BMD_TYPE = 'sd',BMR = 1)
BB_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_two,
fit_type = "laplace",BMD_TYPE = 'hybrid',BMR = 0.05,point_p = 0.025)
BB_l$bmd
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "laplace",BMD_TYPE = 'hybrid',BMR = 0.05,point_p = 0.025)
AA_l$bmd
jj = 2
y = sim_data[jj,]
print(jj)
library(ToxicR)
prior_list_one = list()
for (i in 1:nrow(model_list)){
t_prior = bayesian_prior_continuous_default(model_list$model_list[i],model_list$distribution_list[i])
if(model_list$distribution_list[i] == "lognormal"){
t_prior$priors[nrow(t_prior$priors),2] = log(var(log(y)))
}else{
if (model_list$distribution_list[i] == "normal"){
t_prior$priors[nrow(t_prior$priors),2]   = log(var(y))
}else{
t_prior$priors[nrow(t_prior$priors),2]   = log(mean(y)/var(y))
}
}
prior_list_one[[i]] = create_continuous_prior(t_prior,model_list$model_list[i],model_list$distribution_list[i])
}
prior_list_two = list()
for (i in 1:nrow(model_list2)){
t_prior = bayesian_prior_continuous_default(model_list2$model_list[i],model_list2$distribution_list[i])
if(model_list$distribution_list[i] == "lognormal"){
t_prior$priors[nrow(t_prior$priors),2] = log(var(log(y)))
}else{
t_prior$priors[nrow(t_prior$priors),2]   = log(var(y))
}
prior_list_two[[i]] = create_continuous_prior(t_prior,model_list2$model_list[i],model_list2$distribution_list[i])
}
AA_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_one,
fit_type = "laplace",BMD_TYPE = 'hybrid',BMR = 0.05,point_p = 0.025)
print( as.numeric(sprintf("%1.3f",AA_l$posterior_probs)))
BB_l <- ma_continuous_fit(as.matrix(doses),as.matrix(y),model_list=prior_list_two,
fit_type = "laplace",BMD_TYPE = 'hybrid',BMR = 0.05,point_p = 0.025)
cat(sprintf(" %f  %f \n", AA_l$bmd,BB_l$bmd))
print( as.numeric(sprintf("%1.3f",AA_l$posterior_probs)))
plot(BB_l)
AA_l$Individual_Model_5$bmd
AA_l$Individual_Model_8$bmd
AA_l$Individual_Model_1$bmd
AA_l$Individual_Model_2$bmd
AA_l$Individual_Model_3$bmd
AA_l$Individual_Model_4$bmd
AA_l$Individual_Model_5$bmd
AA_l$Individual_Model_6$bmd
library(ToxicR)
library(tidyverse)
model_listA  = data.frame(model_list = c(rep("hill",2),rep("exp-3",3),rep("exp-5",3),rep("power",2)),
distribution_list =  c(c("normal","normal-ncv"),rep(c("normal","normal-ncv","lognormal"),2),
"normal", "normal-ncv"))
a  = "\Ux2623"
a  = "\U2623"
a
setwd("~/Documents/r_software/RBMDS/ToxicR/src/code_base")
a = "\UU2620"
a = "\U2620"
a
setwd("~/Documents/r_software/RBMDS/ToxicR/src/code_base")
